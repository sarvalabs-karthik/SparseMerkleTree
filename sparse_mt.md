In a merkle tree, we calculates hash of leaves and Hashes of branches in a binary tree fashion to obtain root.
let's consider n as number of leaves
In case of sorted KV store, it takes O(2^(n))time to calculate merkle root every time.
Incase of insert, it takes O(n) time for shifting elements to right in array and merkle root needs to be calculated again which is inefficient.
Incase of remove, it takes O(n) time to shift elements to right and merkle root needs to be calculated again which is inefficient.
Inorder to generate merkle proof, we need to recompute hashes. it takes O(log n) time.
It's not easy to understand and traverse merkle tree incase of sorted kv store, 
which is prone to more bugs as algorithms will be complex for proof calculation and merkle root generation.

We introduce Sparse Merkle Tree which has lot of advantages over sorted_kv implementation.
In SMT, keys are located using bitstring generated by hash of the key from root.
0 denotes left and 1 denotes right in the bit string.
Empty subtrees can be represented using zero Hash.
If there is a single leave in a sub tree, it can be merged into single node (i.e leaf) (reference: Libra White Paper).
This optimizes the no of hashes needed to be calculated while performing operations on SMT.
Insert operation takes O(log n) where n is no of leaves in the tree as log(n)
denotes the depth of the tree which we need to traverse in worst case.
Merkle root is calculated during insert operation, so we need calculate hash log(n) times along the path
Remove, proof calculation operations are also optimized to O(log n).
Each key is in unique a leaf as it will be hashed using SHA-256 which is a collision resistant hash function
We rely on Zero digest, as hash function always produces unique digests.

If two SMT's has different digests but differ in only one key, it means that hash function isn't collission resistant.

Proof:
lets say merkle trees are M1 = MHT(xi...xj) M2 = MHT(xi'...xj)
let's say merkle proof for xi and xi' = (h1,h2,..hj) where j is the depth of tree.
let's say (p1,p2,...,pk) && (p1',p2',...,pk')are the hashes generated along the path where p = H(pi-1,hi) where i is the level in tree

extreme cases:
case-1: H(H(xi'),p1') should have been equal to H(H(xi),p1), eventhough xi'!=xi which means there is a collision in H.
case-2: H(pk',hj) should have been equal to H(pk,hj), eventhough pk'!=pk which means there is a collision in H.
Therfore collision would have happened at any level along the path by yielding same hash for two different inputs.
