In a merkle tree, we calculates hash of leaves and Hashes of branches in a binary tree fashion to obtain root.
let's consider K as number of leaves in tree
In case of sorted KV store, it takes O(K)time to calculate merkle root every time.
Incase of insert, it takes O(K) time for shifting elements to right in array and merkle root needs to be calculated again which is inefficient.
Incase of remove, it takes O(K) time to shift elements to right and merkle root needs to be calculated again which is inefficient.
Inorder to generate merkle proof, we need to recompute hashes. it takes O(log n) time. where n = no of nodes in tree
It's not easy to understand and traverse merkle tree incase of sorted kv store, 
which is prone to more bugs as algorithms will be complex for proof calculation and merkle root generation.

We introduce Sparse Merkle Tree which has lot of advantages over sorted_kv implementation.
In SMT, keys are located using bitstring generated by hash of the key from root.
0 denotes left and 1 denotes right in the bit string.
Empty subtrees can be represented using zero Hash.
If there is a single leave in a sub tree, it can be merged into single node (i.e leaf) (reference: Libra White Paper).
This optimizes the no of hashes needed to be calculated while performing operations on SMT.
Insert operation takes O(log K) where K = no of leaves in the tree.
denotes the depth of the tree which we need to traverse in worst case.
Merkle root is calculated during insert operation, so we need calculate hash log(K) times along the path
Remove, proof calculation operations are also optimized to O(log K).
Each key is in unique a leaf as it will be hashed using SHA-256 which is a collision resistant hash function
We rely on Zero digest, as hash function always produces unique digests.

If two SMT's has different digests but differ in only one key, it means that hash function isn't collission resistant.

Proof:
lets say merkle trees are M1 = MHT(xi...xj) M2 = MHT(xi'...xj)
let's say merkle proof for xi and xi' = (h1,h2,..hj) where j is the depth of tree.
let's say (p1,p2,...,pj) && (p1',p2',...,pj') are the hashes generated along the path where p = H(pj-1,hj)

extreme cases:
case-1: H(H(xi'),p1') should have been equal to H(H(xi),p1), eventhough xi'!=xi which means there is a collision in H.
case-2: H(pj',hj) should have been equal to H(pj,hj), eventhough pk'!=pk which means there is a collision in H.
Therfore collision would have happened at any level along the path by yielding same hash for two different inputs.

Efficient Implementation of SMT:
1. In current implementation it takes 256 hash calculations for every operation as depth of the tree is equal to no of bits in Key hash.
2. But this can be optimized to O(log K) operations where K = no of leafs in tree.
3. I have proposed following algorithms for insert and remove on SMT to save space and time over the current implementation.
4. INSERT - Efficient:
4.1. Create a variable called key of type digest in Node, as it is useful in extending prefix
4.2. Traverse along the path of key bit string
4.3. Once a leaf is found, find the common prefix between current key and leaf key.
4.4. Create the default nodes until common prefix ends.
4.5. Now create the nodes as left and right childs according to direction bit to the last prefix node.
4.6. If there is no leaf then create the node there itself. There are only two cases when there won't be a leaf node.
4.7. while inserting First key starting with bit 0(0…).
4.8. while inserting Second key starting with bit 1(1…).
4.9. while inserting we need to relocate at max 1 node.
5. REMOVE - Efficient:
5.1. Traverse till the leaf. 
5.2. make leaf's hash as zero digest
5.2. While traversing back, if both leaf's hashes are zero digest then remove both childs and make this node's hash as zero digest.
5.3 If one of the leaf's hash is non-zero the recalculate it's hash.
5.4. we need to shorten the sibling branch of leaf to the root as well here.
5.5. Inorder to do this we need to keep track of key prefix.
5.6. Traverse along key prefix and then siblings direction untill a node with two non-zero digest childs are found.
5.7. While traversing back if the child (non-leaf) has only one of the node as zero digest, the remove the node and recalculate hash.